var Yt=Object.defineProperty;var dt=(e,t)=>{for(var r in t)Yt(e,r,{get:t[r],enumerable:!0})};var u=crypto,x=e=>e instanceof CryptoKey;var qt=async(e,t)=>{let r=`SHA-${e.slice(-3)}`;return new Uint8Array(await u.subtle.digest(r,t))},_e=qt;var E=new TextEncoder,K=new TextDecoder,Ke=2**32;function W(...e){let t=e.reduce((a,{length:o})=>a+o,0),r=new Uint8Array(t),n=0;return e.forEach(a=>{r.set(a,n),n+=a.length}),r}function pt(e,t){return W(E.encode(e),new Uint8Array([0]),t)}function Me(e,t,r){if(t<0||t>=Ke)throw new RangeError(`value must be >= 0 and <= ${Ke-1}. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,t&255],r)}function He(e){let t=Math.floor(e/Ke),r=e%Ke,n=new Uint8Array(8);return Me(n,t,0),Me(n,r,4),n}function Ce(e){let t=new Uint8Array(4);return Me(t,e),t}function Pe(e){return W(Ce(e.length),e)}async function ft(e,t,r){let n=Math.ceil((t>>3)/32),a=new Uint8Array(n*32);for(let o=0;o<n;o++){let i=new Uint8Array(4+e.length+r.length);i.set(Ce(o+1)),i.set(e,4),i.set(r,4+e.length),a.set(await _e("sha256",i),o*32)}return a.slice(0,t>>3)}var ve=e=>{let t=e;typeof t=="string"&&(t=E.encode(t));let r=32768,n=[];for(let a=0;a<t.length;a+=r)n.push(String.fromCharCode.apply(null,t.subarray(a,a+r)));return btoa(n.join(""))},g=e=>ve(e).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),Ne=e=>{let t=atob(e),r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return r},_=e=>{let t=e;t instanceof Uint8Array&&(t=K.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return Ne(t)}catch(r){throw new TypeError("The input to be decoded is not correctly encoded.")}};var Le={};dt(Le,{JOSEAlgNotAllowed:()=>B,JOSEError:()=>C,JOSENotSupported:()=>h,JWEDecryptionFailed:()=>N,JWEInvalid:()=>p,JWKInvalid:()=>de,JWKSInvalid:()=>$,JWKSMultipleMatchingKeys:()=>pe,JWKSNoMatchingKey:()=>q,JWKSTimeout:()=>fe,JWSInvalid:()=>m,JWSSignatureVerificationFailed:()=>Z,JWTClaimValidationFailed:()=>v,JWTExpired:()=>re,JWTInvalid:()=>H});var C=class extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(t){var r;super(t),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,(r=Error.captureStackTrace)==null||r.call(Error,this,this.constructor)}},v=class extends C{static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}constructor(t,r="unspecified",n="unspecified"){super(t),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=r,this.reason=n}},re=class extends C{static get code(){return"ERR_JWT_EXPIRED"}constructor(t,r="unspecified",n="unspecified"){super(t),this.code="ERR_JWT_EXPIRED",this.claim=r,this.reason=n}},B=class extends C{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}},h=class extends C{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}},N=class extends C{constructor(){super(...arguments),this.code="ERR_JWE_DECRYPTION_FAILED",this.message="decryption operation failed"}static get code(){return"ERR_JWE_DECRYPTION_FAILED"}},p=class extends C{constructor(){super(...arguments),this.code="ERR_JWE_INVALID"}static get code(){return"ERR_JWE_INVALID"}},m=class extends C{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}},H=class extends C{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}},de=class extends C{constructor(){super(...arguments),this.code="ERR_JWK_INVALID"}static get code(){return"ERR_JWK_INVALID"}},$=class extends C{constructor(){super(...arguments),this.code="ERR_JWKS_INVALID"}static get code(){return"ERR_JWKS_INVALID"}},q=class extends C{constructor(){super(...arguments),this.code="ERR_JWKS_NO_MATCHING_KEY",this.message="no applicable key found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_NO_MATCHING_KEY"}},pe=class extends C{constructor(){super(...arguments),this.code="ERR_JWKS_MULTIPLE_MATCHING_KEYS",this.message="multiple matching keys found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_MULTIPLE_MATCHING_KEYS"}},fe=class extends C{constructor(){super(...arguments),this.code="ERR_JWKS_TIMEOUT",this.message="request timed out"}static get code(){return"ERR_JWKS_TIMEOUT"}},Z=class extends C{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}};var k=u.getRandomValues.bind(u);function Be(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new h(`Unsupported JWE Algorithm: ${e}`)}}var We=e=>k(new Uint8Array(Be(e)>>3));var Zt=(e,t)=>{if(t.length<<3!==Be(e))throw new p("Invalid Initialization Vector length")},Je=Zt;var Qt=(e,t)=>{let r=e.byteLength<<3;if(r!==t)throw new p(`Invalid Content Encryption Key length. Expected ${t} bits, got ${r} bits`)},ne=Qt;var jt=(e,t)=>{if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(e.length!==t.length)throw new TypeError("Input buffers must have the same length");let r=e.length,n=0,a=-1;for(;++a<r;)n|=e[a]^t[a];return n===0},ht=jt;function J(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function G(e,t){return e.name===t}function Ie(e){return parseInt(e.name.slice(4),10)}function er(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}function mt(e,t){if(t.length&&!t.some(r=>e.usages.includes(r))){let r="CryptoKey does not support this operation, its usages must include ";if(t.length>2){let n=t.pop();r+=`one of ${t.join(", ")}, or ${n}.`}else t.length===2?r+=`one of ${t[0]} or ${t[1]}.`:r+=`${t[0]}.`;throw new TypeError(r)}}function lt(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!G(e.algorithm,"HMAC"))throw J("HMAC");let n=parseInt(t.slice(2),10);if(Ie(e.algorithm.hash)!==n)throw J(`SHA-${n}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!G(e.algorithm,"RSASSA-PKCS1-v1_5"))throw J("RSASSA-PKCS1-v1_5");let n=parseInt(t.slice(2),10);if(Ie(e.algorithm.hash)!==n)throw J(`SHA-${n}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!G(e.algorithm,"RSA-PSS"))throw J("RSA-PSS");let n=parseInt(t.slice(2),10);if(Ie(e.algorithm.hash)!==n)throw J(`SHA-${n}`,"algorithm.hash");break}case"EdDSA":{if(e.algorithm.name!=="Ed25519"&&e.algorithm.name!=="Ed448")throw J("Ed25519 or Ed448");break}case"ES256":case"ES384":case"ES512":{if(!G(e.algorithm,"ECDSA"))throw J("ECDSA");let n=er(t);if(e.algorithm.namedCurve!==n)throw J(n,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}mt(e,r)}function I(e,t,...r){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!G(e.algorithm,"AES-GCM"))throw J("AES-GCM");let n=parseInt(t.slice(1,4),10);if(e.algorithm.length!==n)throw J(n,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!G(e.algorithm,"AES-KW"))throw J("AES-KW");let n=parseInt(t.slice(1,4),10);if(e.algorithm.length!==n)throw J(n,"algorithm.length");break}case"ECDH":{switch(e.algorithm.name){case"ECDH":case"X25519":case"X448":break;default:throw J("ECDH, X25519, or X448")}break}case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!G(e.algorithm,"PBKDF2"))throw J("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!G(e.algorithm,"RSA-OAEP"))throw J("RSA-OAEP");let n=parseInt(t.slice(9),10)||1;if(Ie(e.algorithm.hash)!==n)throw J(`SHA-${n}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}mt(e,r)}function yt(e,t,...r){if(r.length>2){let n=r.pop();e+=`one of type ${r.join(", ")}, or ${n}.`}else r.length===2?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return t==null?e+=` Received ${t}`:typeof t=="function"&&t.name?e+=` Received function ${t.name}`:typeof t=="object"&&t!=null&&t.constructor&&t.constructor.name&&(e+=` Received an instance of ${t.constructor.name}`),e}var b=(e,...t)=>yt("Key must be ",e,...t);function $e(e,t,...r){return yt(`Key for the ${e} algorithm must be `,t,...r)}var ke=e=>x(e),y=["CryptoKey"];async function tr(e,t,r,n,a,o){if(!(t instanceof Uint8Array))throw new TypeError(b(t,"Uint8Array"));let i=parseInt(e.slice(1,4),10),c=await u.subtle.importKey("raw",t.subarray(i>>3),"AES-CBC",!1,["decrypt"]),s=await u.subtle.importKey("raw",t.subarray(0,i>>3),{hash:`SHA-${i<<1}`,name:"HMAC"},!1,["sign"]),d=W(o,n,r,He(o.length<<3)),f=new Uint8Array((await u.subtle.sign("HMAC",s,d)).slice(0,i>>3)),A;try{A=ht(a,f)}catch(S){}if(!A)throw new N;let P;try{P=new Uint8Array(await u.subtle.decrypt({iv:n,name:"AES-CBC"},c,r))}catch(S){}if(!P)throw new N;return P}async function rr(e,t,r,n,a,o){let i;t instanceof Uint8Array?i=await u.subtle.importKey("raw",t,"AES-GCM",!1,["decrypt"]):(I(t,e,"decrypt"),i=t);try{return new Uint8Array(await u.subtle.decrypt({additionalData:o,iv:n,name:"AES-GCM",tagLength:128},i,W(r,a)))}catch(c){throw new N}}var nr=async(e,t,r,n,a,o)=>{if(!x(t)&&!(t instanceof Uint8Array))throw new TypeError(b(t,...y,"Uint8Array"));switch(Je(e,n),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return t instanceof Uint8Array&&ne(t,parseInt(e.slice(-3),10)),tr(e,t,r,n,a,o);case"A128GCM":case"A192GCM":case"A256GCM":return t instanceof Uint8Array&&ne(t,parseInt(e.slice(1,4),10)),rr(e,t,r,n,a,o);default:throw new h("Unsupported JWE Content Encryption Algorithm")}},Te=nr;var ar=(...e)=>{let t=e.filter(Boolean);if(t.length===0||t.length===1)return!0;let r;for(let n of t){let a=Object.keys(n);if(!r||r.size===0){r=new Set(a);continue}for(let o of a){if(r.has(o))return!1;r.add(o)}}return!0},R=ar;function or(e){return typeof e=="object"&&e!==null}function w(e){if(!or(e)||Object.prototype.toString.call(e)!=="[object Object]")return!1;if(Object.getPrototypeOf(e)===null)return!0;let t=e;for(;Object.getPrototypeOf(t)!==null;)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}var ir=[{hash:"SHA-256",name:"HMAC"},!0,["sign"]],ae=ir;function wt(e,t){if(e.algorithm.length!==parseInt(t.slice(1,4),10))throw new TypeError(`Invalid key size for alg: ${t}`)}function Et(e,t,r){if(x(e))return I(e,t,r),e;if(e instanceof Uint8Array)return u.subtle.importKey("raw",e,"AES-KW",!0,[r]);throw new TypeError(b(e,...y,"Uint8Array"))}var ue=async(e,t,r)=>{let n=await Et(t,e,"wrapKey");wt(n,e);let a=await u.subtle.importKey("raw",r,...ae);return new Uint8Array(await u.subtle.wrapKey("raw",a,n,"AES-KW"))},he=async(e,t,r)=>{let n=await Et(t,e,"unwrapKey");wt(n,e);let a=await u.subtle.unwrapKey("raw",r,n,"AES-KW",...ae);return new Uint8Array(await u.subtle.exportKey("raw",a))};async function Re(e,t,r,n,a=new Uint8Array(0),o=new Uint8Array(0)){if(!x(e))throw new TypeError(b(e,...y));if(I(e,"ECDH"),!x(t))throw new TypeError(b(t,...y));I(t,"ECDH","deriveBits");let i=W(Pe(E.encode(r)),Pe(a),Pe(o),Ce(n)),c;e.algorithm.name==="X25519"?c=256:e.algorithm.name==="X448"?c=448:c=Math.ceil(parseInt(e.algorithm.namedCurve.substr(-3),10)/8)<<3;let s=new Uint8Array(await u.subtle.deriveBits({name:e.algorithm.name,public:e},t,c));return ft(s,n,i)}async function gt(e){if(!x(e))throw new TypeError(b(e,...y));return u.subtle.generateKey(e.algorithm,!0,["deriveBits"])}function Oe(e){if(!x(e))throw new TypeError(b(e,...y));return["P-256","P-384","P-521"].includes(e.algorithm.namedCurve)||e.algorithm.name==="X25519"||e.algorithm.name==="X448"}function Ge(e){if(!(e instanceof Uint8Array)||e.length<8)throw new p("PBES2 Salt Input must be 8 or more octets")}function sr(e,t){if(e instanceof Uint8Array)return u.subtle.importKey("raw",e,"PBKDF2",!1,["deriveBits"]);if(x(e))return I(e,t,"deriveBits","deriveKey"),e;throw new TypeError(b(e,...y,"Uint8Array"))}async function At(e,t,r,n){Ge(e);let a=pt(t,e),o=parseInt(t.slice(13,16),10),i={hash:`SHA-${t.slice(8,11)}`,iterations:r,name:"PBKDF2",salt:a},c={length:o,name:"AES-KW"},s=await sr(n,t);if(s.usages.includes("deriveBits"))return new Uint8Array(await u.subtle.deriveBits(i,s,o));if(s.usages.includes("deriveKey"))return u.subtle.deriveKey(i,s,c,!1,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}var bt=async(e,t,r,n=2048,a=k(new Uint8Array(16)))=>{let o=await At(a,e,n,t);return{encryptedKey:await ue(e.slice(-6),o,r),p2c:n,p2s:g(a)}},xt=async(e,t,r,n,a)=>{let o=await At(a,e,n,t);return he(e.slice(-6),o,r)};function oe(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new h(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}var Q=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){let{modulusLength:r}=t.algorithm;if(typeof r!="number"||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};var _t=async(e,t,r)=>{if(!x(t))throw new TypeError(b(t,...y));if(I(t,e,"encrypt","wrapKey"),Q(e,t),t.usages.includes("encrypt"))return new Uint8Array(await u.subtle.encrypt(oe(e),t,r));if(t.usages.includes("wrapKey")){let n=await u.subtle.importKey("raw",r,...ae);return new Uint8Array(await u.subtle.wrapKey("raw",n,t,oe(e)))}throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation')},Kt=async(e,t,r)=>{if(!x(t))throw new TypeError(b(t,...y));if(I(t,e,"decrypt","unwrapKey"),Q(e,t),t.usages.includes("decrypt"))return new Uint8Array(await u.subtle.decrypt(oe(e),t,r));if(t.usages.includes("unwrapKey")){let n=await u.subtle.unwrapKey("raw",r,t,oe(e),...ae);return new Uint8Array(await u.subtle.exportKey("raw",n))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')};function me(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new h(`Unsupported JWE Algorithm: ${e}`)}}var O=e=>k(new Uint8Array(me(e)>>3));var Fe=(e,t)=>{let r=(e.match(/.{1,64}/g)||[]).join(`
`);return`-----BEGIN ${t}-----
${r}
-----END ${t}-----`};var Pt=async(e,t,r)=>{if(!x(r))throw new TypeError(b(r,...y));if(!r.extractable)throw new TypeError("CryptoKey is not extractable");if(r.type!==e)throw new TypeError(`key is not a ${e} key`);return Fe(ve(new Uint8Array(await u.subtle.exportKey(t,r))),`${e.toUpperCase()} KEY`)},vt=e=>Pt("public","spki",e),Wt=e=>Pt("private","pkcs8",e),F=(e,t,r=0)=>{r===0&&(t.unshift(t.length),t.unshift(6));let n=e.indexOf(t[0],r);if(n===-1)return!1;let a=e.subarray(n,n+t.length);return a.length!==t.length?!1:a.every((o,i)=>o===t[i])||F(e,t,n+1)},Ht=e=>{switch(!0){case F(e,[42,134,72,206,61,3,1,7]):return"P-256";case F(e,[43,129,4,0,34]):return"P-384";case F(e,[43,129,4,0,35]):return"P-521";case F(e,[43,101,110]):return"X25519";case F(e,[43,101,111]):return"X448";case F(e,[43,101,112]):return"Ed25519";case F(e,[43,101,113]):return"Ed448";default:throw new h("Invalid or unsupported EC Key Curve or OKP Key Sub Type")}},Jt=async(e,t,r,n,a)=>{var d;let o,i,c=new Uint8Array(atob(r.replace(e,"")).split("").map(f=>f.charCodeAt(0))),s=t==="spki";switch(n){case"PS256":case"PS384":case"PS512":o={name:"RSA-PSS",hash:`SHA-${n.slice(-3)}`},i=s?["verify"]:["sign"];break;case"RS256":case"RS384":case"RS512":o={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${n.slice(-3)}`},i=s?["verify"]:["sign"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":o={name:"RSA-OAEP",hash:`SHA-${parseInt(n.slice(-3),10)||1}`},i=s?["encrypt","wrapKey"]:["decrypt","unwrapKey"];break;case"ES256":o={name:"ECDSA",namedCurve:"P-256"},i=s?["verify"]:["sign"];break;case"ES384":o={name:"ECDSA",namedCurve:"P-384"},i=s?["verify"]:["sign"];break;case"ES512":o={name:"ECDSA",namedCurve:"P-521"},i=s?["verify"]:["sign"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{let f=Ht(c);o=f.startsWith("P-")?{name:"ECDH",namedCurve:f}:{name:f},i=s?[]:["deriveBits"];break}case"EdDSA":o={name:Ht(c)},i=s?["verify"]:["sign"];break;default:throw new h('Invalid or unsupported "alg" (Algorithm) value')}return u.subtle.importKey(t,c,o,(d=a==null?void 0:a.extractable)!=null?d:!1,i)},It=(e,t,r)=>Jt(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g,"pkcs8",e,t,r),Ve=(e,t,r)=>Jt(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g,"spki",e,t,r);function Ct(e){let t=[],r=0;for(;r<e.length;){let n=Tt(e.subarray(r));t.push(n),r+=n.byteLength}return t}function Tt(e){let t=0,r=e[0]&31;if(t++,r===31){for(r=0;e[t]>=128;)r=r*128+e[t]-128,t++;r=r*128+e[t]-128,t++}let n=0;if(e[t]<128)n=e[t],t++;else if(n===128){for(n=0;e[t+n]!==0||e[t+n+1]!==0;){if(n>e.byteLength)throw new TypeError("invalid indefinite form length");n++}let o=t+n+2;return{byteLength:o,contents:e.subarray(t,t+n),raw:e.subarray(0,o)}}else{let o=e[t]&127;t++,n=0;for(let i=0;i<o;i++)n=n*256+e[t],t++}let a=t+n;return{byteLength:a,contents:e.subarray(t,a),raw:e.subarray(0,a)}}function cr(e){let t=Ct(Ct(Tt(e).contents)[0].contents);return ve(t[t[0].raw[0]===160?6:5].raw)}function dr(e){let t=e.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g,""),r=Ne(t);return Fe(cr(r),"PUBLIC KEY")}var Rt=(e,t,r)=>{let n;try{n=dr(e)}catch(a){throw new TypeError("Failed to parse the X.509 certificate",{cause:a})}return Ve(n,t,r)};function pr(e){let t,r;switch(e.kty){case"RSA":{switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new h('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"EC":{switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new h('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"OKP":{switch(e.alg){case"EdDSA":t={name:e.crv},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new h('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}default:throw new h('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}var fr=async e=>{var o,i;if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');let{algorithm:t,keyUsages:r}=pr(e),n=[t,(o=e.ext)!=null?o:!1,(i=e.key_ops)!=null?i:r],a={...e};return delete a.alg,delete a.use,u.subtle.importKey("jwk",a,...n)},Ot=fr;async function ur(e,t,r){if(typeof e!="string"||e.indexOf("-----BEGIN PUBLIC KEY-----")!==0)throw new TypeError('"spki" must be SPKI formatted string');return Ve(e,t,r)}async function hr(e,t,r){if(typeof e!="string"||e.indexOf("-----BEGIN CERTIFICATE-----")!==0)throw new TypeError('"x509" must be X.509 formatted string');return Rt(e,t,r)}async function mr(e,t,r){if(typeof e!="string"||e.indexOf("-----BEGIN PRIVATE KEY-----")!==0)throw new TypeError('"pkcs8" must be PKCS#8 formatted string');return It(e,t,r)}async function j(e,t){if(!w(e))throw new TypeError("JWK must be an object");switch(t||(t=e.alg),e.kty){case"oct":if(typeof e.k!="string"||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return _(e.k);case"RSA":if(e.oth!==void 0)throw new h('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return Ot({...e,alg:t});default:throw new h('Unsupported "kty" (Key Type) Parameter value')}}var lr=(e,t)=>{if(!(t instanceof Uint8Array)){if(!ke(t))throw new TypeError($e(e,t,...y,"Uint8Array"));if(t.type!=="secret")throw new TypeError(`${y.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}},yr=(e,t,r)=>{if(!ke(t))throw new TypeError($e(e,t,...y));if(t.type==="secret")throw new TypeError(`${y.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if(r==="sign"&&t.type==="public")throw new TypeError(`${y.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if(r==="decrypt"&&t.type==="public")throw new TypeError(`${y.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&r==="verify"&&t.type==="private")throw new TypeError(`${y.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&r==="encrypt"&&t.type==="private")throw new TypeError(`${y.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)},wr=(e,t,r)=>{e.startsWith("HS")||e==="dir"||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?lr(e,t):yr(e,t,r)},V=wr;async function Er(e,t,r,n,a){if(!(r instanceof Uint8Array))throw new TypeError(b(r,"Uint8Array"));let o=parseInt(e.slice(1,4),10),i=await u.subtle.importKey("raw",r.subarray(o>>3),"AES-CBC",!1,["encrypt"]),c=await u.subtle.importKey("raw",r.subarray(0,o>>3),{hash:`SHA-${o<<1}`,name:"HMAC"},!1,["sign"]),s=new Uint8Array(await u.subtle.encrypt({iv:n,name:"AES-CBC"},i,t)),d=W(a,n,s,He(a.length<<3)),f=new Uint8Array((await u.subtle.sign("HMAC",c,d)).slice(0,o>>3));return{ciphertext:s,tag:f}}async function gr(e,t,r,n,a){let o;r instanceof Uint8Array?o=await u.subtle.importKey("raw",r,"AES-GCM",!1,["encrypt"]):(I(r,e,"encrypt"),o=r);let i=new Uint8Array(await u.subtle.encrypt({additionalData:a,iv:n,name:"AES-GCM",tagLength:128},o,t)),c=i.slice(-16);return{ciphertext:i.slice(0,-16),tag:c}}var Sr=async(e,t,r,n,a)=>{if(!x(r)&&!(r instanceof Uint8Array))throw new TypeError(b(r,...y,"Uint8Array"));switch(Je(e,n),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return r instanceof Uint8Array&&ne(r,parseInt(e.slice(-3),10)),Er(e,t,r,n,a);case"A128GCM":case"A192GCM":case"A256GCM":return r instanceof Uint8Array&&ne(r,parseInt(e.slice(1,4),10)),gr(e,t,r,n,a);default:throw new h("Unsupported JWE Content Encryption Algorithm")}},Ue=Sr;async function Ut(e,t,r,n){let a=e.slice(0,7);n||(n=We(a));let{ciphertext:o,tag:i}=await Ue(a,r,t,n,new Uint8Array(0));return{encryptedKey:o,iv:g(n),tag:g(i)}}async function Dt(e,t,r,n,a){let o=e.slice(0,7);return Te(o,t,r,n,a,new Uint8Array(0))}async function Ar(e,t,r,n,a){switch(V(e,t,"decrypt"),e){case"dir":{if(r!==void 0)throw new p("Encountered unexpected JWE Encrypted Key");return t}case"ECDH-ES":if(r!==void 0)throw new p("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!w(n.epk))throw new p('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!Oe(t))throw new h("ECDH with the provided key is not allowed or not supported by your javascript runtime");let o=await j(n.epk,e),i,c;if(n.apu!==void 0){if(typeof n.apu!="string")throw new p('JOSE Header "apu" (Agreement PartyUInfo) invalid');try{i=_(n.apu)}catch(d){throw new p("Failed to base64url decode the apu")}}if(n.apv!==void 0){if(typeof n.apv!="string")throw new p('JOSE Header "apv" (Agreement PartyVInfo) invalid');try{c=_(n.apv)}catch(d){throw new p("Failed to base64url decode the apv")}}let s=await Re(o,t,e==="ECDH-ES"?n.enc:e,e==="ECDH-ES"?me(n.enc):parseInt(e.slice(-5,-2),10),i,c);if(e==="ECDH-ES")return s;if(r===void 0)throw new p("JWE Encrypted Key missing");return he(e.slice(-6),s,r)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(r===void 0)throw new p("JWE Encrypted Key missing");return Kt(e,t,r)}case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{if(r===void 0)throw new p("JWE Encrypted Key missing");if(typeof n.p2c!="number")throw new p('JOSE Header "p2c" (PBES2 Count) missing or invalid');let o=(a==null?void 0:a.maxPBES2Count)||1e4;if(n.p2c>o)throw new p('JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds');if(typeof n.p2s!="string")throw new p('JOSE Header "p2s" (PBES2 Salt) missing or invalid');let i;try{i=_(n.p2s)}catch(c){throw new p("Failed to base64url decode the p2s")}return xt(e,t,r,n.p2c,i)}case"A128KW":case"A192KW":case"A256KW":{if(r===void 0)throw new p("JWE Encrypted Key missing");return he(e,t,r)}case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{if(r===void 0)throw new p("JWE Encrypted Key missing");if(typeof n.iv!="string")throw new p('JOSE Header "iv" (Initialization Vector) missing or invalid');if(typeof n.tag!="string")throw new p('JOSE Header "tag" (Authentication Tag) missing or invalid');let o;try{o=_(n.iv)}catch(c){throw new p("Failed to base64url decode the iv")}let i;try{i=_(n.tag)}catch(c){throw new p("Failed to base64url decode the tag")}return Dt(e,t,r,o,i)}default:throw new h('Invalid or unsupported "alg" (JWE Algorithm) header value')}}var Mt=Ar;function br(e,t,r,n,a){if(a.crit!==void 0&&n.crit===void 0)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||n.crit===void 0)return new Set;if(!Array.isArray(n.crit)||n.crit.length===0||n.crit.some(i=>typeof i!="string"||i.length===0))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let o;r!==void 0?o=new Map([...Object.entries(r),...t.entries()]):o=t;for(let i of n.crit){if(!o.has(i))throw new h(`Extension Header Parameter "${i}" is not recognized`);if(a[i]===void 0)throw new e(`Extension Header Parameter "${i}" is missing`);if(o.get(i)&&n[i]===void 0)throw new e(`Extension Header Parameter "${i}" MUST be integrity protected`)}return new Set(n.crit)}var U=br;var xr=(e,t)=>{if(t!==void 0&&(!Array.isArray(t)||t.some(r=>typeof r!="string")))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)},le=xr;async function ye(e,t,r){var ct;if(!w(e))throw new p("Flattened JWE must be an object");if(e.protected===void 0&&e.header===void 0&&e.unprotected===void 0)throw new p("JOSE Header missing");if(typeof e.iv!="string")throw new p("JWE Initialization Vector missing or incorrect type");if(typeof e.ciphertext!="string")throw new p("JWE Ciphertext missing or incorrect type");if(typeof e.tag!="string")throw new p("JWE Authentication Tag missing or incorrect type");if(e.protected!==void 0&&typeof e.protected!="string")throw new p("JWE Protected Header incorrect type");if(e.encrypted_key!==void 0&&typeof e.encrypted_key!="string")throw new p("JWE Encrypted Key incorrect type");if(e.aad!==void 0&&typeof e.aad!="string")throw new p("JWE AAD incorrect type");if(e.header!==void 0&&!w(e.header))throw new p("JWE Shared Unprotected Header incorrect type");if(e.unprotected!==void 0&&!w(e.unprotected))throw new p("JWE Per-Recipient Unprotected Header incorrect type");let n;if(e.protected)try{let T=_(e.protected);n=JSON.parse(K.decode(T))}catch(T){throw new p("JWE Protected Header is invalid")}if(!R(n,e.header,e.unprotected))throw new p("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");let a={...n,...e.header,...e.unprotected};if(U(p,new Map,r==null?void 0:r.crit,n,a),a.zip!==void 0)throw new h('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');let{alg:o,enc:i}=a;if(typeof o!="string"||!o)throw new p("missing JWE Algorithm (alg) in JWE Header");if(typeof i!="string"||!i)throw new p("missing JWE Encryption Algorithm (enc) in JWE Header");let c=r&&le("keyManagementAlgorithms",r.keyManagementAlgorithms),s=r&&le("contentEncryptionAlgorithms",r.contentEncryptionAlgorithms);if(c&&!c.has(o)||!c&&o.startsWith("PBES2"))throw new B('"alg" (Algorithm) Header Parameter value not allowed');if(s&&!s.has(i))throw new B('"enc" (Encryption Algorithm) Header Parameter value not allowed');let d;if(e.encrypted_key!==void 0)try{d=_(e.encrypted_key)}catch(T){throw new p("Failed to base64url decode the encrypted_key")}let f=!1;typeof t=="function"&&(t=await t(n,e),f=!0);let A;try{A=await Mt(o,t,d,a,r)}catch(T){if(T instanceof TypeError||T instanceof p||T instanceof h)throw T;A=O(i)}let P,S;try{P=_(e.iv)}catch(T){throw new p("Failed to base64url decode the iv")}try{S=_(e.tag)}catch(T){throw new p("Failed to base64url decode the tag")}let l=E.encode((ct=e.protected)!=null?ct:""),D;e.aad!==void 0?D=W(l,E.encode("."),E.encode(e.aad)):D=l;let M;try{M=_(e.ciphertext)}catch(T){throw new p("Failed to base64url decode the ciphertext")}let te={plaintext:await Te(i,A,M,P,S,D)};if(e.protected!==void 0&&(te.protectedHeader=n),e.aad!==void 0)try{te.additionalAuthenticatedData=_(e.aad)}catch(T){throw new p("Failed to base64url decode the aad")}return e.unprotected!==void 0&&(te.sharedUnprotectedHeader=e.unprotected),e.header!==void 0&&(te.unprotectedHeader=e.header),f?{...te,key:t}:te}async function Xe(e,t,r){if(e instanceof Uint8Array&&(e=K.decode(e)),typeof e!="string")throw new p("Compact JWE must be a string or Uint8Array");let{0:n,1:a,2:o,3:i,4:c,length:s}=e.split(".");if(s!==5)throw new p("Invalid Compact JWE");let d=await ye({ciphertext:i,iv:o||void 0,protected:n||void 0,tag:c||void 0,encrypted_key:a||void 0},t,r),f={plaintext:d.plaintext,protectedHeader:d.protectedHeader};return typeof t=="function"?{...f,key:d.key}:f}async function _r(e,t,r){if(!w(e))throw new p("General JWE must be an object");if(!Array.isArray(e.recipients)||!e.recipients.every(w))throw new p("JWE Recipients missing or incorrect type");if(!e.recipients.length)throw new p("JWE Recipients has no members");for(let n of e.recipients)try{return await ye({aad:e.aad,ciphertext:e.ciphertext,encrypted_key:n.encrypted_key,header:n.header,iv:e.iv,protected:e.protected,tag:e.tag,unprotected:e.unprotected},t,r)}catch(a){}throw new N}var Kr=async e=>{if(e instanceof Uint8Array)return{kty:"oct",k:g(e)};if(!x(e))throw new TypeError(b(e,...y,"Uint8Array"));if(!e.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");let{ext:t,key_ops:r,alg:n,use:a,...o}=await u.subtle.exportKey("jwk",e);return o},Nt=Kr;async function Hr(e){return vt(e)}async function Cr(e){return Wt(e)}async function ze(e){return Nt(e)}async function Pr(e,t,r,n,a={}){let o,i,c;switch(V(e,r,"encrypt"),e){case"dir":{c=r;break}case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!Oe(r))throw new h("ECDH with the provided key is not allowed or not supported by your javascript runtime");let{apu:s,apv:d}=a,{epk:f}=a;f||(f=(await gt(r)).privateKey);let{x:A,y:P,crv:S,kty:l}=await ze(f),D=await Re(r,f,e==="ECDH-ES"?t:e,e==="ECDH-ES"?me(t):parseInt(e.slice(-5,-2),10),s,d);if(i={epk:{x:A,crv:S,kty:l}},l==="EC"&&(i.epk.y=P),s&&(i.apu=g(s)),d&&(i.apv=g(d)),e==="ECDH-ES"){c=D;break}c=n||O(t);let M=e.slice(-6);o=await ue(M,D,c);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{c=n||O(t),o=await _t(e,r,c);break}case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{c=n||O(t);let{p2c:s,p2s:d}=a;({encryptedKey:o,...i}=await bt(e,r,c,s,d));break}case"A128KW":case"A192KW":case"A256KW":{c=n||O(t),o=await ue(e,r,c);break}case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{c=n||O(t);let{iv:s}=a;({encryptedKey:o,...i}=await Ut(e,r,c,s));break}default:throw new h('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek:c,encryptedKey:o,parameters:i}}var De=Pr;var Ye=Symbol(),X=class{constructor(t){if(!(t instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this._plaintext=t}setKeyManagementParameters(t){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=t,this}setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setSharedUnprotectedHeader(t){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=t,this}setUnprotectedHeader(t){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=t,this}setAdditionalAuthenticatedData(t){return this._aad=t,this}setContentEncryptionKey(t){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=t,this}setInitializationVector(t){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=t,this}async encrypt(t,r){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new p("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!R(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new p("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");let n={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(U(p,new Map,r==null?void 0:r.crit,this._protectedHeader,n),n.zip!==void 0)throw new h('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');let{alg:a,enc:o}=n;if(typeof a!="string"||!a)throw new p('JWE "alg" (Algorithm) Header Parameter missing or invalid');if(typeof o!="string"||!o)throw new p('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let i;if(a==="dir"){if(this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption")}else if(a==="ECDH-ES"&&this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");let c;{let l;({cek:c,encryptedKey:i,parameters:l}=await De(a,o,t,this._cek,this._keyManagementParameters)),l&&(r&&Ye in r?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...l}:this.setUnprotectedHeader(l):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...l}:this.setProtectedHeader(l))}this._iv||(this._iv=We(o));let s,d,f;this._protectedHeader?d=E.encode(g(JSON.stringify(this._protectedHeader))):d=E.encode(""),this._aad?(f=g(this._aad),s=W(d,E.encode("."),E.encode(f))):s=d;let{ciphertext:A,tag:P}=await Ue(o,this._plaintext,c,this._iv,s),S={ciphertext:g(A),iv:g(this._iv),tag:g(P)};return i&&(S.encrypted_key=g(i)),f&&(S.aad=f),this._protectedHeader&&(S.protected=K.decode(d)),this._sharedUnprotectedHeader&&(S.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(S.header=this._unprotectedHeader),S}};var qe=class{constructor(t,r,n){this.parent=t,this.key=r,this.options=n}setUnprotectedHeader(t){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=t,this}addRecipient(...t){return this.parent.addRecipient(...t)}encrypt(...t){return this.parent.encrypt(...t)}done(){return this.parent}},Ze=class{constructor(t){this._recipients=[],this._plaintext=t}addRecipient(t,r){let n=new qe(this,t,{crit:r==null?void 0:r.crit});return this._recipients.push(n),n}setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setSharedUnprotectedHeader(t){if(this._unprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._unprotectedHeader=t,this}setAdditionalAuthenticatedData(t){return this._aad=t,this}async encrypt(){var a,o,i;if(!this._recipients.length)throw new p("at least one recipient must be added");if(this._recipients.length===1){let[c]=this._recipients,s=await new X(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(c.unprotectedHeader).encrypt(c.key,{...c.options}),d={ciphertext:s.ciphertext,iv:s.iv,recipients:[{}],tag:s.tag};return s.aad&&(d.aad=s.aad),s.protected&&(d.protected=s.protected),s.unprotected&&(d.unprotected=s.unprotected),s.encrypted_key&&(d.recipients[0].encrypted_key=s.encrypted_key),s.header&&(d.recipients[0].header=s.header),d}let t;for(let c=0;c<this._recipients.length;c++){let s=this._recipients[c];if(!R(this._protectedHeader,this._unprotectedHeader,s.unprotectedHeader))throw new p("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");let d={...this._protectedHeader,...this._unprotectedHeader,...s.unprotectedHeader},{alg:f}=d;if(typeof f!="string"||!f)throw new p('JWE "alg" (Algorithm) Header Parameter missing or invalid');if(f==="dir"||f==="ECDH-ES")throw new p('"dir" and "ECDH-ES" alg may only be used with a single recipient');if(typeof d.enc!="string"||!d.enc)throw new p('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');if(!t)t=d.enc;else if(t!==d.enc)throw new p('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');if(U(p,new Map,s.options.crit,this._protectedHeader,d),d.zip!==void 0)throw new h('JWE "zip" (Compression Algorithm) Header Parameter is not supported.')}let r=O(t),n={ciphertext:"",iv:"",recipients:[],tag:""};for(let c=0;c<this._recipients.length;c++){let s=this._recipients[c],d={};n.recipients.push(d);let A={...this._protectedHeader,...this._unprotectedHeader,...s.unprotectedHeader}.alg.startsWith("PBES2")?2048+c:void 0;if(c===0){let l=await new X(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(r).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(s.unprotectedHeader).setKeyManagementParameters({p2c:A}).encrypt(s.key,{...s.options,[Ye]:!0});n.ciphertext=l.ciphertext,n.iv=l.iv,n.tag=l.tag,l.aad&&(n.aad=l.aad),l.protected&&(n.protected=l.protected),l.unprotected&&(n.unprotected=l.unprotected),d.encrypted_key=l.encrypted_key,l.header&&(d.header=l.header);continue}let{encryptedKey:P,parameters:S}=await De(((a=s.unprotectedHeader)==null?void 0:a.alg)||((o=this._protectedHeader)==null?void 0:o.alg)||((i=this._unprotectedHeader)==null?void 0:i.alg),t,s.key,r,{p2c:A});d.encrypted_key=g(P),(s.unprotectedHeader||S)&&(d.header={...s.unprotectedHeader,...S})}return n}};function we(e,t){let r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"EdDSA":return{name:t.name};default:throw new h(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}function Ee(e,t,r){if(x(t))return lt(t,e,r),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(b(t,...y));return u.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[r])}throw new TypeError(b(t,...y,"Uint8Array"))}var vr=async(e,t,r,n)=>{let a=await Ee(e,t,"verify");Q(e,a);let o=we(e,a.algorithm);try{return await u.subtle.verify(o,a,r,n)}catch(i){return!1}},Lt=vr;async function ge(e,t,r){var D;if(!w(e))throw new m("Flattened JWS must be an object");if(e.protected===void 0&&e.header===void 0)throw new m('Flattened JWS must have either of the "protected" or "header" members');if(e.protected!==void 0&&typeof e.protected!="string")throw new m("JWS Protected Header incorrect type");if(e.payload===void 0)throw new m("JWS Payload missing");if(typeof e.signature!="string")throw new m("JWS Signature missing or incorrect type");if(e.header!==void 0&&!w(e.header))throw new m("JWS Unprotected Header incorrect type");let n={};if(e.protected)try{let M=_(e.protected);n=JSON.parse(K.decode(M))}catch(M){throw new m("JWS Protected Header is invalid")}if(!R(n,e.header))throw new m("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");let a={...n,...e.header},o=U(m,new Map([["b64",!0]]),r==null?void 0:r.crit,n,a),i=!0;if(o.has("b64")&&(i=n.b64,typeof i!="boolean"))throw new m('The "b64" (base64url-encode payload) Header Parameter must be a boolean');let{alg:c}=a;if(typeof c!="string"||!c)throw new m('JWS "alg" (Algorithm) Header Parameter missing or invalid');let s=r&&le("algorithms",r.algorithms);if(s&&!s.has(c))throw new B('"alg" (Algorithm) Header Parameter value not allowed');if(i){if(typeof e.payload!="string")throw new m("JWS Payload must be a string")}else if(typeof e.payload!="string"&&!(e.payload instanceof Uint8Array))throw new m("JWS Payload must be a string or an Uint8Array instance");let d=!1;typeof t=="function"&&(t=await t(n,e),d=!0),V(c,t,"verify");let f=W(E.encode((D=e.protected)!=null?D:""),E.encode("."),typeof e.payload=="string"?E.encode(e.payload):e.payload),A;try{A=_(e.signature)}catch(M){throw new m("Failed to base64url decode the signature")}if(!await Lt(c,t,A,f))throw new Z;let S;if(i)try{S=_(e.payload)}catch(M){throw new m("Failed to base64url decode the payload")}else typeof e.payload=="string"?S=E.encode(e.payload):S=e.payload;let l={payload:S};return e.protected!==void 0&&(l.protectedHeader=n),e.header!==void 0&&(l.unprotectedHeader=e.header),d?{...l,key:t}:l}async function Qe(e,t,r){if(e instanceof Uint8Array&&(e=K.decode(e)),typeof e!="string")throw new m("Compact JWS must be a string or Uint8Array");let{0:n,1:a,2:o,length:i}=e.split(".");if(i!==3)throw new m("Invalid Compact JWS");let c=await ge({payload:a,protected:n,signature:o},t,r),s={payload:c.payload,protectedHeader:c.protectedHeader};return typeof t=="function"?{...s,key:c.key}:s}async function Wr(e,t,r){if(!w(e))throw new m("General JWS must be an object");if(!Array.isArray(e.signatures)||!e.signatures.every(w))throw new m("JWS Signatures missing or incorrect type");for(let n of e.signatures)try{return await ge({header:n.header,payload:e.payload,protected:n.protected,signature:n.signature},t,r)}catch(a){}throw new Z}var L=e=>Math.floor(e.getTime()/1e3);var Jr=/^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i,ie=e=>{let t=Jr.exec(e);if(!t)throw new TypeError("Invalid time period format");let r=parseFloat(t[1]);switch(t[2].toLowerCase()){case"sec":case"secs":case"second":case"seconds":case"s":return Math.round(r);case"minute":case"minutes":case"min":case"mins":case"m":return Math.round(r*60);case"hour":case"hours":case"hr":case"hrs":case"h":return Math.round(r*3600);case"day":case"days":case"d":return Math.round(r*86400);case"week":case"weeks":case"w":return Math.round(r*604800);default:return Math.round(r*31557600)}};var Bt=e=>e.toLowerCase().replace(/^application\//,""),Ir=(e,t)=>typeof e=="string"?t.includes(e):Array.isArray(e)?t.some(Set.prototype.has.bind(new Set(e))):!1,se=(e,t,r={})=>{let{typ:n}=r;if(n&&(typeof e.typ!="string"||Bt(e.typ)!==Bt(n)))throw new v('unexpected "typ" JWT header value',"typ","check_failed");let a;try{a=JSON.parse(K.decode(t))}catch(S){}if(!w(a))throw new H("JWT Claims Set must be a top-level JSON object");let{requiredClaims:o=[],issuer:i,subject:c,audience:s,maxTokenAge:d}=r;d!==void 0&&o.push("iat"),s!==void 0&&o.push("aud"),c!==void 0&&o.push("sub"),i!==void 0&&o.push("iss");for(let S of new Set(o.reverse()))if(!(S in a))throw new v(`missing required "${S}" claim`,S,"missing");if(i&&!(Array.isArray(i)?i:[i]).includes(a.iss))throw new v('unexpected "iss" claim value',"iss","check_failed");if(c&&a.sub!==c)throw new v('unexpected "sub" claim value',"sub","check_failed");if(s&&!Ir(a.aud,typeof s=="string"?[s]:s))throw new v('unexpected "aud" claim value',"aud","check_failed");let f;switch(typeof r.clockTolerance){case"string":f=ie(r.clockTolerance);break;case"number":f=r.clockTolerance;break;case"undefined":f=0;break;default:throw new TypeError("Invalid clockTolerance option type")}let{currentDate:A}=r,P=L(A||new Date);if((a.iat!==void 0||d)&&typeof a.iat!="number")throw new v('"iat" claim must be a number',"iat","invalid");if(a.nbf!==void 0){if(typeof a.nbf!="number")throw new v('"nbf" claim must be a number',"nbf","invalid");if(a.nbf>P+f)throw new v('"nbf" claim timestamp check failed',"nbf","check_failed")}if(a.exp!==void 0){if(typeof a.exp!="number")throw new v('"exp" claim must be a number',"exp","invalid");if(a.exp<=P-f)throw new re('"exp" claim timestamp check failed',"exp","check_failed")}if(d){let S=P-a.iat,l=typeof d=="number"?d:ie(d);if(S-f>l)throw new re('"iat" claim timestamp check failed (too far in the past)',"iat","check_failed");if(S<0-f)throw new v('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}return a};async function Tr(e,t,r){var i;let n=await Qe(e,t,r);if((i=n.protectedHeader.crit)!=null&&i.includes("b64")&&n.protectedHeader.b64===!1)throw new H("JWTs MUST NOT use unencoded payload");let o={payload:se(n.protectedHeader,n.payload,r),protectedHeader:n.protectedHeader};return typeof t=="function"?{...o,key:n.key}:o}async function Rr(e,t,r){let n=await Xe(e,t,r),a=se(n.protectedHeader,n.plaintext,r),{protectedHeader:o}=n;if(o.iss!==void 0&&o.iss!==a.iss)throw new v('replicated "iss" claim header parameter mismatch',"iss","mismatch");if(o.sub!==void 0&&o.sub!==a.sub)throw new v('replicated "sub" claim header parameter mismatch',"sub","mismatch");if(o.aud!==void 0&&JSON.stringify(o.aud)!==JSON.stringify(a.aud))throw new v('replicated "aud" claim header parameter mismatch',"aud","mismatch");let i={payload:a,protectedHeader:o};return typeof t=="function"?{...i,key:n.key}:i}var Se=class{constructor(t){this._flattened=new X(t)}setContentEncryptionKey(t){return this._flattened.setContentEncryptionKey(t),this}setInitializationVector(t){return this._flattened.setInitializationVector(t),this}setProtectedHeader(t){return this._flattened.setProtectedHeader(t),this}setKeyManagementParameters(t){return this._flattened.setKeyManagementParameters(t),this}async encrypt(t,r){let n=await this._flattened.encrypt(t,r);return[n.protected,n.encrypted_key,n.iv,n.ciphertext,n.tag].join(".")}};var Or=async(e,t,r)=>{let n=await Ee(e,t,"sign");Q(e,n);let a=await u.subtle.sign(we(e,n.algorithm),n,r);return new Uint8Array(a)},$t=Or;var ee=class{constructor(t){if(!(t instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=t}setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setUnprotectedHeader(t){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=t,this}async sign(t,r){if(!this._protectedHeader&&!this._unprotectedHeader)throw new m("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!R(this._protectedHeader,this._unprotectedHeader))throw new m("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");let n={...this._protectedHeader,...this._unprotectedHeader},a=U(m,new Map([["b64",!0]]),r==null?void 0:r.crit,this._protectedHeader,n),o=!0;if(a.has("b64")&&(o=this._protectedHeader.b64,typeof o!="boolean"))throw new m('The "b64" (base64url-encode payload) Header Parameter must be a boolean');let{alg:i}=n;if(typeof i!="string"||!i)throw new m('JWS "alg" (Algorithm) Header Parameter missing or invalid');V(i,t,"sign");let c=this._payload;o&&(c=E.encode(g(c)));let s;this._protectedHeader?s=E.encode(g(JSON.stringify(this._protectedHeader))):s=E.encode("");let d=W(s,E.encode("."),c),f=await $t(i,t,d),A={signature:g(f),payload:""};return o&&(A.payload=K.decode(c)),this._unprotectedHeader&&(A.header=this._unprotectedHeader),this._protectedHeader&&(A.protected=K.decode(s)),A}};var Ae=class{constructor(t){this._flattened=new ee(t)}setProtectedHeader(t){return this._flattened.setProtectedHeader(t),this}async sign(t,r){let n=await this._flattened.sign(t,r);if(n.payload===void 0)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${n.protected}.${n.payload}.${n.signature}`}};var je=class{constructor(t,r,n){this.parent=t,this.key=r,this.options=n}setProtectedHeader(t){if(this.protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this.protectedHeader=t,this}setUnprotectedHeader(t){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=t,this}addSignature(...t){return this.parent.addSignature(...t)}sign(...t){return this.parent.sign(...t)}done(){return this.parent}},et=class{constructor(t){this._signatures=[],this._payload=t}addSignature(t,r){let n=new je(this,t,r);return this._signatures.push(n),n}async sign(){if(!this._signatures.length)throw new m("at least one signature must be added");let t={signatures:[],payload:""};for(let r=0;r<this._signatures.length;r++){let n=this._signatures[r],a=new ee(this._payload);a.setProtectedHeader(n.protectedHeader),a.setUnprotectedHeader(n.unprotectedHeader);let{payload:o,...i}=await a.sign(n.key,n.options);if(r===0)t.payload=o;else if(t.payload!==o)throw new m("inconsistent use of JWS Unencoded Payload (RFC7797)");t.signatures.push(i)}return t}};function ce(e,t){if(!Number.isFinite(t))throw new TypeError(`Invalid ${e} input`);return t}var z=class{constructor(t={}){if(!w(t))throw new TypeError("JWT Claims Set MUST be an object");this._payload=t}setIssuer(t){return this._payload={...this._payload,iss:t},this}setSubject(t){return this._payload={...this._payload,sub:t},this}setAudience(t){return this._payload={...this._payload,aud:t},this}setJti(t){return this._payload={...this._payload,jti:t},this}setNotBefore(t){return typeof t=="number"?this._payload={...this._payload,nbf:ce("setNotBefore",t)}:t instanceof Date?this._payload={...this._payload,nbf:ce("setNotBefore",L(t))}:this._payload={...this._payload,nbf:L(new Date)+ie(t)},this}setExpirationTime(t){return typeof t=="number"?this._payload={...this._payload,exp:ce("setExpirationTime",t)}:t instanceof Date?this._payload={...this._payload,exp:ce("setExpirationTime",L(t))}:this._payload={...this._payload,exp:L(new Date)+ie(t)},this}setIssuedAt(t){return typeof t=="undefined"?this._payload={...this._payload,iat:L(new Date)}:t instanceof Date?this._payload={...this._payload,iat:ce("setIssuedAt",L(t))}:this._payload={...this._payload,iat:ce("setIssuedAt",t)},this}};var tt=class extends z{setProtectedHeader(t){return this._protectedHeader=t,this}async sign(t,r){var a;let n=new Ae(E.encode(JSON.stringify(this._payload)));if(n.setProtectedHeader(this._protectedHeader),Array.isArray((a=this._protectedHeader)==null?void 0:a.crit)&&this._protectedHeader.crit.includes("b64")&&this._protectedHeader.b64===!1)throw new H("JWTs MUST NOT use unencoded payload");return n.sign(t,r)}};var rt=class extends z{setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setKeyManagementParameters(t){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=t,this}setContentEncryptionKey(t){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=t,this}setInitializationVector(t){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=t,this}replicateIssuerAsHeader(){return this._replicateIssuerAsHeader=!0,this}replicateSubjectAsHeader(){return this._replicateSubjectAsHeader=!0,this}replicateAudienceAsHeader(){return this._replicateAudienceAsHeader=!0,this}async encrypt(t,r){let n=new Se(E.encode(JSON.stringify(this._payload)));return this._replicateIssuerAsHeader&&(this._protectedHeader={...this._protectedHeader,iss:this._payload.iss}),this._replicateSubjectAsHeader&&(this._protectedHeader={...this._protectedHeader,sub:this._payload.sub}),this._replicateAudienceAsHeader&&(this._protectedHeader={...this._protectedHeader,aud:this._payload.aud}),n.setProtectedHeader(this._protectedHeader),this._iv&&n.setInitializationVector(this._iv),this._cek&&n.setContentEncryptionKey(this._cek),this._keyManagementParameters&&n.setKeyManagementParameters(this._keyManagementParameters),n.encrypt(t,r)}};var Y=(e,t)=>{if(typeof e!="string"||!e)throw new de(`${t} missing or invalid`)};async function kt(e,t){if(!w(e))throw new TypeError("JWK must be an object");if(t!=null||(t="sha256"),t!=="sha256"&&t!=="sha384"&&t!=="sha512")throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');let r;switch(e.kty){case"EC":Y(e.crv,'"crv" (Curve) Parameter'),Y(e.x,'"x" (X Coordinate) Parameter'),Y(e.y,'"y" (Y Coordinate) Parameter'),r={crv:e.crv,kty:e.kty,x:e.x,y:e.y};break;case"OKP":Y(e.crv,'"crv" (Subtype of Key Pair) Parameter'),Y(e.x,'"x" (Public Key) Parameter'),r={crv:e.crv,kty:e.kty,x:e.x};break;case"RSA":Y(e.e,'"e" (Exponent) Parameter'),Y(e.n,'"n" (Modulus) Parameter'),r={e:e.e,kty:e.kty,n:e.n};break;case"oct":Y(e.k,'"k" (Key Value) Parameter'),r={k:e.k,kty:e.kty};break;default:throw new h('"kty" (Key Type) Parameter missing or unsupported')}let n=E.encode(JSON.stringify(r));return g(await _e(t,n))}async function Ur(e,t){t!=null||(t="sha256");let r=await kt(e,t);return`urn:ietf:params:oauth:jwk-thumbprint:sha-${t.slice(-3)}:${r}`}async function Dr(e,t){let r={...e,...t==null?void 0:t.header};if(!w(r.jwk))throw new m('"jwk" (JSON Web Key) Header Parameter must be a JSON object');let n=await j({...r.jwk,ext:!0},r.alg);if(n instanceof Uint8Array||n.type!=="public")throw new m('"jwk" (JSON Web Key) Header Parameter must be a public key');return n}function Mr(e){switch(typeof e=="string"&&e.slice(0,2)){case"RS":case"PS":return"RSA";case"ES":return"EC";case"Ed":return"OKP";default:throw new h('Unsupported "alg" value for a JSON Web Key Set')}}function nt(e){return e&&typeof e=="object"&&Array.isArray(e.keys)&&e.keys.every(Nr)}function Nr(e){return w(e)}function Lr(e){return typeof structuredClone=="function"?structuredClone(e):JSON.parse(JSON.stringify(e))}var be=class{constructor(t){if(this._cached=new WeakMap,!nt(t))throw new $("JSON Web Key Set malformed");this._jwks=Lr(t)}async getKey(t,r){let{alg:n,kid:a}={...t,...r==null?void 0:r.header},o=Mr(n),i=this._jwks.keys.filter(d=>{let f=o===d.kty;if(f&&typeof a=="string"&&(f=a===d.kid),f&&typeof d.alg=="string"&&(f=n===d.alg),f&&typeof d.use=="string"&&(f=d.use==="sig"),f&&Array.isArray(d.key_ops)&&(f=d.key_ops.includes("verify")),f&&n==="EdDSA"&&(f=d.crv==="Ed25519"||d.crv==="Ed448"),f)switch(n){case"ES256":f=d.crv==="P-256";break;case"ES256K":f=d.crv==="secp256k1";break;case"ES384":f=d.crv==="P-384";break;case"ES512":f=d.crv==="P-521";break}return f}),{0:c,length:s}=i;if(s===0)throw new q;if(s!==1){let d=new pe,{_cached:f}=this;throw d[Symbol.asyncIterator]=async function*(){for(let A of i)try{yield await Gt(f,A,n)}catch(P){continue}},d}return Gt(this._cached,c,n)}};async function Gt(e,t,r){let n=e.get(t)||e.set(t,{}).get(t);if(n[r]===void 0){let a=await j({...t,ext:!0},r);if(a instanceof Uint8Array||a.type!=="public")throw new $("JSON Web Key Set members must be public keys");n[r]=a}return n[r]}function Br(e){let t=new be(e);return async function(r,n){return t.getKey(r,n)}}var $r=async(e,t,r)=>{let n,a,o=!1;typeof AbortController=="function"&&(n=new AbortController,a=setTimeout(()=>{o=!0,n.abort()},t));let i=await fetch(e.href,{signal:n?n.signal:void 0,redirect:"manual",headers:r.headers}).catch(c=>{throw o?new fe:c});if(a!==void 0&&clearTimeout(a),i.status!==200)throw new C("Expected 200 OK from the JSON Web Key Set HTTP response");try{return await i.json()}catch(c){throw new C("Failed to parse the JSON Web Key Set HTTP response as JSON")}},Ft=$r;function kr(){return typeof WebSocketPair!="undefined"||typeof navigator!="undefined"&&navigator.userAgent==="Cloudflare-Workers"||typeof EdgeRuntime!="undefined"&&EdgeRuntime==="vercel"}var at=class extends be{constructor(t,r){if(super({keys:[]}),this._jwks=void 0,!(t instanceof URL))throw new TypeError("url must be an instance of URL");this._url=new URL(t.href),this._options={agent:r==null?void 0:r.agent,headers:r==null?void 0:r.headers},this._timeoutDuration=typeof(r==null?void 0:r.timeoutDuration)=="number"?r==null?void 0:r.timeoutDuration:5e3,this._cooldownDuration=typeof(r==null?void 0:r.cooldownDuration)=="number"?r==null?void 0:r.cooldownDuration:3e4,this._cacheMaxAge=typeof(r==null?void 0:r.cacheMaxAge)=="number"?r==null?void 0:r.cacheMaxAge:6e5}coolingDown(){return typeof this._jwksTimestamp=="number"?Date.now()<this._jwksTimestamp+this._cooldownDuration:!1}fresh(){return typeof this._jwksTimestamp=="number"?Date.now()<this._jwksTimestamp+this._cacheMaxAge:!1}async getKey(t,r){(!this._jwks||!this.fresh())&&await this.reload();try{return await super.getKey(t,r)}catch(n){if(n instanceof q&&this.coolingDown()===!1)return await this.reload(),super.getKey(t,r);throw n}}async reload(){this._pendingFetch&&kr()&&(this._pendingFetch=void 0),this._pendingFetch||(this._pendingFetch=Ft(this._url,this._timeoutDuration,this._options).then(t=>{if(!nt(t))throw new $("JSON Web Key Set malformed");this._jwks={keys:t.keys},this._jwksTimestamp=Date.now(),this._pendingFetch=void 0}).catch(t=>{throw this._pendingFetch=void 0,t})),await this._pendingFetch}};function Gr(e,t){let r=new at(e,t);return async function(n,a){return r.getKey(n,a)}}var ot=class extends z{encode(){let t=g(JSON.stringify({alg:"none"})),r=g(JSON.stringify(this._payload));return`${t}.${r}.`}static decode(t,r){if(typeof t!="string")throw new H("Unsecured JWT must be a string");let{0:n,1:a,2:o,length:i}=t.split(".");if(i!==3||o!=="")throw new H("Invalid Unsecured JWT");let c;try{if(c=JSON.parse(K.decode(_(n))),c.alg!=="none")throw new Error}catch(d){throw new H("Invalid Unsecured JWT")}return{payload:se(c,_(a),r),header:c}}};var it={};dt(it,{decode:()=>xe,encode:()=>Fr});var Fr=g,xe=_;function Vr(e){let t;if(typeof e=="string"){let r=e.split(".");(r.length===3||r.length===5)&&([t]=r)}else if(typeof e=="object"&&e)if("protected"in e)t=e.protected;else throw new TypeError("Token does not contain a Protected Header");try{if(typeof t!="string"||!t)throw new Error;let r=JSON.parse(K.decode(xe(t)));if(!w(r))throw new Error;return r}catch(r){throw new TypeError("Invalid Token or Protected Header formatting")}}function Xr(e){if(typeof e!="string")throw new H("JWTs must use Compact JWS serialization, JWT must be a string");let{1:t,length:r}=e.split(".");if(r===5)throw new H("Only JWTs using Compact JWS serialization can be decoded");if(r!==3)throw new H("Invalid JWT");if(!t)throw new H("JWTs must contain a payload");let n;try{n=xe(t)}catch(o){throw new H("Failed to base64url decode the payload")}let a;try{a=JSON.parse(K.decode(n))}catch(o){throw new H("Failed to parse the decoded payload as JSON")}if(!w(a))throw new H("Invalid JWT Claims Set");return a}async function Vt(e,t){var o;let r,n,a;switch(e){case"HS256":case"HS384":case"HS512":r=parseInt(e.slice(-3),10),n={name:"HMAC",hash:`SHA-${r}`,length:r},a=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return r=parseInt(e.slice(-3),10),k(new Uint8Array(r>>3));case"A128KW":case"A192KW":case"A256KW":r=parseInt(e.slice(1,4),10),n={name:"AES-KW",length:r},a=["wrapKey","unwrapKey"];break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":case"A128GCM":case"A192GCM":case"A256GCM":r=parseInt(e.slice(1,4),10),n={name:"AES-GCM",length:r},a=["encrypt","decrypt"];break;default:throw new h('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return u.subtle.generateKey(n,(o=t==null?void 0:t.extractable)!=null?o:!1,a)}function st(e){var r;let t=(r=e==null?void 0:e.modulusLength)!=null?r:2048;if(typeof t!="number"||t<2048)throw new h("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");return t}async function Xt(e,t){var a,o,i;let r,n;switch(e){case"PS256":case"PS384":case"PS512":r={name:"RSA-PSS",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:st(t)},n=["sign","verify"];break;case"RS256":case"RS384":case"RS512":r={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:st(t)},n=["sign","verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":r={name:"RSA-OAEP",hash:`SHA-${parseInt(e.slice(-3),10)||1}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:st(t)},n=["decrypt","unwrapKey","encrypt","wrapKey"];break;case"ES256":r={name:"ECDSA",namedCurve:"P-256"},n=["sign","verify"];break;case"ES384":r={name:"ECDSA",namedCurve:"P-384"},n=["sign","verify"];break;case"ES512":r={name:"ECDSA",namedCurve:"P-521"},n=["sign","verify"];break;case"EdDSA":n=["sign","verify"];let c=(a=t==null?void 0:t.crv)!=null?a:"Ed25519";switch(c){case"Ed25519":case"Ed448":r={name:c};break;default:throw new h("Invalid or unsupported crv option provided")}break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{n=["deriveKey","deriveBits"];let s=(o=t==null?void 0:t.crv)!=null?o:"P-256";switch(s){case"P-256":case"P-384":case"P-521":{r={name:"ECDH",namedCurve:s};break}case"X25519":case"X448":r={name:s};break;default:throw new h("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448")}break}default:throw new h('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return u.subtle.generateKey(r,(i=t==null?void 0:t.extractable)!=null?i:!1,n)}async function zr(e,t){return Xt(e,t)}async function Yr(e,t){return Vt(e,t)}var zt="WebCryptoAPI";var qr=zt;export{Se as CompactEncrypt,Ae as CompactSign,Dr as EmbeddedJWK,rt as EncryptJWT,X as FlattenedEncrypt,ee as FlattenedSign,Ze as GeneralEncrypt,et as GeneralSign,tt as SignJWT,ot as UnsecuredJWT,it as base64url,kt as calculateJwkThumbprint,Ur as calculateJwkThumbprintUri,Xe as compactDecrypt,Qe as compactVerify,Br as createLocalJWKSet,Gr as createRemoteJWKSet,qr as cryptoRuntime,Xr as decodeJwt,Vr as decodeProtectedHeader,Le as errors,ze as exportJWK,Cr as exportPKCS8,Hr as exportSPKI,ye as flattenedDecrypt,ge as flattenedVerify,_r as generalDecrypt,Wr as generalVerify,zr as generateKeyPair,Yr as generateSecret,j as importJWK,mr as importPKCS8,ur as importSPKI,hr as importX509,Rr as jwtDecrypt,Tr as jwtVerify};
